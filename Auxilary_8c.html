<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>qpSWIFT: Auxilary.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">qpSWIFT
   </div>
   <div id="projectbrief">A Sparse Quadratic Programming Solver</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('Auxilary_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Auxilary.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Auxilary_8h_source.html">Auxilary.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Auxilary.c:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab763700450e282af9ddf438e1545ecda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#ab763700450e282af9ddf438e1545ecda">formkktmatrix_U</a> (<a class="el" href="structsmat.html">smat</a> *P, <a class="el" href="structsmat.html">smat</a> *G, <a class="el" href="structsmat.html">smat</a> *Gt, <a class="el" href="structsmat.html">smat</a> *<a class="el" href="structkkt.html">kkt</a>)</td></tr>
<tr class="separator:ab763700450e282af9ddf438e1545ecda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb373533158b8ae2815472c675bbb368"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#adb373533158b8ae2815472c675bbb368">formkktmatrix_full</a> (<a class="el" href="structsmat.html">smat</a> *P, <a class="el" href="structsmat.html">smat</a> *G, <a class="el" href="structsmat.html">smat</a> *A, <a class="el" href="structsmat.html">smat</a> *Gt, <a class="el" href="structsmat.html">smat</a> *At, <a class="el" href="structsmat.html">smat</a> *<a class="el" href="structkkt.html">kkt</a>)</td></tr>
<tr class="memdesc:adb373533158b8ae2815472c675bbb368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembles the KKT matrix.  <a href="Auxilary_8c.html#adb373533158b8ae2815472c675bbb368">More...</a><br /></td></tr>
<tr class="separator:adb373533158b8ae2815472c675bbb368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd460d31cc93071880545e49d47c87ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#abd460d31cc93071880545e49d47c87ce">updatekktmatrix</a> (<a class="el" href="structsmat.html">smat</a> *<a class="el" href="structkkt.html">kkt</a>, qp_real *s, qp_real *z, qp_real *delta_s, qp_real *delta_z, qp_real alpha_p, qp_real alpha_d, qp_int m, qp_int n, qp_int p, qp_int indicator)</td></tr>
<tr class="memdesc:abd460d31cc93071880545e49d47c87ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lower diagonal part of the kkt Matrix,.  <a href="Auxilary_8c.html#abd460d31cc93071880545e49d47c87ce">More...</a><br /></td></tr>
<tr class="separator:abd460d31cc93071880545e49d47c87ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8d89cdd4ec5f5c63e838a3760283ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a4e8d89cdd4ec5f5c63e838a3760283ba">updatevariables</a> (qp_real *x, qp_real *delta_x, qp_real alpha, qp_int count)</td></tr>
<tr class="memdesc:a4e8d89cdd4ec5f5c63e838a3760283ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scalar vector addition.  <a href="Auxilary_8c.html#a4e8d89cdd4ec5f5c63e838a3760283ba">More...</a><br /></td></tr>
<tr class="separator:a4e8d89cdd4ec5f5c63e838a3760283ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf2773ce4d9305e5125c82bc64a8b19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#adaf2773ce4d9305e5125c82bc64a8b19">updatekktmatrix_b</a> (qp_real *b, qp_real *rx, qp_real *ry, qp_real *rz, qp_real *ds, qp_real *z, qp_int n, qp_int m, qp_int p)</td></tr>
<tr class="memdesc:adaf2773ce4d9305e5125c82bc64a8b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the right hand side of the KKT linear system of equations.  <a href="Auxilary_8c.html#adaf2773ce4d9305e5125c82bc64a8b19">More...</a><br /></td></tr>
<tr class="separator:adaf2773ce4d9305e5125c82bc64a8b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe4380baed9e0747c89c746a57d7f1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a6fe4380baed9e0747c89c746a57d7f1c">form_ds</a> (qp_real *ds, qp_real *lambda, qp_real *delta_s, qp_real *delta_z, qp_real sigma, qp_real mu, qp_int m, qp_int selector)</td></tr>
<tr class="memdesc:a6fe4380baed9e0747c89c746a57d7f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the ds vector based on the selector.  <a href="Auxilary_8c.html#a6fe4380baed9e0747c89c746a57d7f1c">More...</a><br /></td></tr>
<tr class="separator:a6fe4380baed9e0747c89c746a57d7f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3399dfc8e5f315c356bea732b7f3eac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a3399dfc8e5f315c356bea732b7f3eac2">findsteplength</a> (qp_real *s, qp_real *delta_s, qp_real *z, qp_real *delta_z, qp_int m, qp_real *alpha_p, qp_real *alpha_d)</td></tr>
<tr class="memdesc:a3399dfc8e5f315c356bea732b7f3eac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the step length.  <a href="Auxilary_8c.html#a3399dfc8e5f315c356bea732b7f3eac2">More...</a><br /></td></tr>
<tr class="separator:a3399dfc8e5f315c356bea732b7f3eac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4ac1455ae148134c3b2b8340d77614"><td class="memItemLeft" align="right" valign="top">qp_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a9f4ac1455ae148134c3b2b8340d77614">checksign</a> (qp_real *x, qp_real *delta_x, qp_real alpha, qp_int count)</td></tr>
<tr class="memdesc:a9f4ac1455ae148134c3b2b8340d77614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if x + alpha*delta_x &lt; 0.  <a href="Auxilary_8c.html#a9f4ac1455ae148134c3b2b8340d77614">More...</a><br /></td></tr>
<tr class="separator:a9f4ac1455ae148134c3b2b8340d77614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a16d6b5e6c10eff3b002d3e39b1b531"><td class="memItemLeft" align="right" valign="top">qp_real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a4a16d6b5e6c10eff3b002d3e39b1b531">norm</a> (qp_real *p, qp_int n)</td></tr>
<tr class="memdesc:a4a16d6b5e6c10eff3b002d3e39b1b531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Eucledian two norm of vector.  <a href="Auxilary_8c.html#a4a16d6b5e6c10eff3b002d3e39b1b531">More...</a><br /></td></tr>
<tr class="separator:a4a16d6b5e6c10eff3b002d3e39b1b531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbda11dfedf5a4f7ce3a67369a346c5"><td class="memItemLeft" align="right" valign="top">qp_real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a2bbda11dfedf5a4f7ce3a67369a346c5">innerproduct</a> (qp_real *x, qp_real *y, qp_int n)</td></tr>
<tr class="memdesc:a2bbda11dfedf5a4f7ce3a67369a346c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inner product of two vectors.  <a href="Auxilary_8c.html#a2bbda11dfedf5a4f7ce3a67369a346c5">More...</a><br /></td></tr>
<tr class="separator:a2bbda11dfedf5a4f7ce3a67369a346c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae747aba2e350a0b16f76d84abcfc8b47"><td class="memItemLeft" align="right" valign="top">qp_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#ae747aba2e350a0b16f76d84abcfc8b47">kktsolve_1</a> (<a class="el" href="structQP.html">QP</a> *myQP)</td></tr>
<tr class="memdesc:ae747aba2e350a0b16f76d84abcfc8b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the KKT linear systems and updates delta_z and delta_s.  <a href="Auxilary_8c.html#ae747aba2e350a0b16f76d84abcfc8b47">More...</a><br /></td></tr>
<tr class="separator:ae747aba2e350a0b16f76d84abcfc8b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e87511977785511d2f27c3a1e292af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a16e87511977785511d2f27c3a1e292af">kktsolve_2</a> (<a class="el" href="structQP.html">QP</a> *myQP)</td></tr>
<tr class="memdesc:a16e87511977785511d2f27c3a1e292af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the kktlinear system from results of kktsolve_1 and updates delta_x, delta_y, delta_z and delta_s.  <a href="Auxilary_8c.html#a16e87511977785511d2f27c3a1e292af">More...</a><br /></td></tr>
<tr class="separator:a16e87511977785511d2f27c3a1e292af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79074eedf41b8fa6171741629624464e"><td class="memItemLeft" align="right" valign="top">qp_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a79074eedf41b8fa6171741629624464e">ldlinitialsolve</a> (<a class="el" href="structkkt.html">kkt</a> *mykkt, qp_real *delta)</td></tr>
<tr class="memdesc:a79074eedf41b8fa6171741629624464e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the kkt linear system to find initial conditions.  <a href="Auxilary_8c.html#a79074eedf41b8fa6171741629624464e">More...</a><br /></td></tr>
<tr class="separator:a79074eedf41b8fa6171741629624464e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf32272524a1aa13205e37a642425eaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#adf32272524a1aa13205e37a642425eaa">formlambda</a> (qp_real *lambda, qp_real *s, qp_real *z, qp_int n)</td></tr>
<tr class="memdesc:adf32272524a1aa13205e37a642425eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scaling point lambda.  <a href="Auxilary_8c.html#adf32272524a1aa13205e37a642425eaa">More...</a><br /></td></tr>
<tr class="separator:adf32272524a1aa13205e37a642425eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9a808a1d46a1de51805cc5c6d9b94e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#acc9a808a1d46a1de51805cc5c6d9b94e">SparseMatrixSetup</a> (qp_int m, qp_int n, qp_int nnz, qp_int *jc, qp_int *ir, qp_real *pr, <a class="el" href="structsmat.html">smat</a> *sparse)</td></tr>
<tr class="memdesc:acc9a808a1d46a1de51805cc5c6d9b94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the Sparse Matrix in Column Compressed Storage Format based on inputs.  <a href="Auxilary_8c.html#acc9a808a1d46a1de51805cc5c6d9b94e">More...</a><br /></td></tr>
<tr class="separator:acc9a808a1d46a1de51805cc5c6d9b94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e90f986dbd2bb32b0ee28fc722d999"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#ac1e90f986dbd2bb32b0ee28fc722d999">Transpose_Row_Count</a> (qp_int m, qp_int n, qp_int *Li, qp_int *Lp, qp_int *Lti, qp_int *Ltp)</td></tr>
<tr class="memdesc:ac1e90f986dbd2bb32b0ee28fc722d999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the ir and jc of transpose of a Matrix.  <a href="Auxilary_8c.html#ac1e90f986dbd2bb32b0ee28fc722d999">More...</a><br /></td></tr>
<tr class="separator:ac1e90f986dbd2bb32b0ee28fc722d999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f5b2eb819f1ebde89875602ab32bde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#ac0f5b2eb819f1ebde89875602ab32bde">computeresiduals</a> (<a class="el" href="structQP.html">QP</a> *myQP)</td></tr>
<tr class="memdesc:ac0f5b2eb819f1ebde89875602ab32bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the residuals rx, ry and rz.  <a href="Auxilary_8c.html#ac0f5b2eb819f1ebde89875602ab32bde">More...</a><br /></td></tr>
<tr class="separator:ac0f5b2eb819f1ebde89875602ab32bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26737ca9366dd8793a56246bc7d14ea8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a26737ca9366dd8793a56246bc7d14ea8">SparseMatrixTransMultiply</a> (<a class="el" href="structsmat.html">smat</a> *A, qp_real *x, qp_real *y, qp_int start)</td></tr>
<tr class="memdesc:a26737ca9366dd8793a56246bc7d14ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Sparse Matrix Transpose Vector Multiplication as.  <a href="Auxilary_8c.html#a26737ca9366dd8793a56246bc7d14ea8">More...</a><br /></td></tr>
<tr class="separator:a26737ca9366dd8793a56246bc7d14ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1c4de7bb55b169a23336387978f9ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a0e1c4de7bb55b169a23336387978f9ce">SparseMatrixMultiply</a> (<a class="el" href="structsmat.html">smat</a> *A, qp_real *x, qp_real *y, qp_int start)</td></tr>
<tr class="memdesc:a0e1c4de7bb55b169a23336387978f9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Sparse Matrix Vector Multiplication as.  <a href="Auxilary_8c.html#a0e1c4de7bb55b169a23336387978f9ce">More...</a><br /></td></tr>
<tr class="separator:a0e1c4de7bb55b169a23336387978f9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34041f76038b85bde98585927b2e4d20"><td class="memItemLeft" align="right" valign="top">qp_real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a34041f76038b85bde98585927b2e4d20">formrho</a> (qp_real *s, qp_real *delta_s, qp_real *z, qp_real *delta_z, qp_real alpha_p, qp_real alpha_d, qp_int n)</td></tr>
<tr class="memdesc:a34041f76038b85bde98585927b2e4d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar rho as.  <a href="Auxilary_8c.html#a34041f76038b85bde98585927b2e4d20">More...</a><br /></td></tr>
<tr class="separator:a34041f76038b85bde98585927b2e4d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64488b6b77275e10a928aa7158f061b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#ae64488b6b77275e10a928aa7158f061b">SparseMatrixTranspose</a> (<a class="el" href="structsmat.html">smat</a> *A, <a class="el" href="structsmat.html">smat</a> *At)</td></tr>
<tr class="memdesc:ae64488b6b77275e10a928aa7158f061b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sparse matrix transpose.  <a href="Auxilary_8c.html#ae64488b6b77275e10a928aa7158f061b">More...</a><br /></td></tr>
<tr class="separator:ae64488b6b77275e10a928aa7158f061b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a675fa6b6ba93e243d39a837264ade3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a0a675fa6b6ba93e243d39a837264ade3">findminmax</a> (qp_real *z, long n, qp_real *min, qp_real *max)</td></tr>
<tr class="memdesc:a0a675fa6b6ba93e243d39a837264ade3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum and maximum of the vector.  <a href="Auxilary_8c.html#a0a675fa6b6ba93e243d39a837264ade3">More...</a><br /></td></tr>
<tr class="separator:a0a675fa6b6ba93e243d39a837264ade3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab220a7f17aea42da2f47e2b41d429f54"><td class="memItemLeft" align="right" valign="top">qp_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#ab220a7f17aea42da2f47e2b41d429f54">kkt_initialize</a> (<a class="el" href="structQP.html">QP</a> *myQP)</td></tr>
<tr class="memdesc:ab220a7f17aea42da2f47e2b41d429f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the initial condition for the <a class="el" href="structQP.html">QP</a> problem.  <a href="Auxilary_8c.html#ab220a7f17aea42da2f47e2b41d429f54">More...</a><br /></td></tr>
<tr class="separator:ab220a7f17aea42da2f47e2b41d429f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129b9809017a0271070faee2a6fabce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a129b9809017a0271070faee2a6fabce1">test_reach</a> (qp_int *Parent, qp_int *Pinv, qp_int *UPattern, qp_int n, qp_int m, qp_int p)</td></tr>
<tr class="memdesc:a129b9809017a0271070faee2a6fabce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nodes to be updated at each iteration.  <a href="Auxilary_8c.html#a129b9809017a0271070faee2a6fabce1">More...</a><br /></td></tr>
<tr class="separator:a129b9809017a0271070faee2a6fabce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c90a6df9cdb57f78dda5d006753259"><td class="memItemLeft" align="right" valign="top">qp_real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a11c90a6df9cdb57f78dda5d006753259">obj_value</a> (<a class="el" href="structsmat.html">smat</a> *P, qp_real *c, qp_real *x, qp_real *temp)</td></tr>
<tr class="memdesc:a11c90a6df9cdb57f78dda5d006753259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the objective function value f = x'Px + c'x.  <a href="Auxilary_8c.html#a11c90a6df9cdb57f78dda5d006753259">More...</a><br /></td></tr>
<tr class="separator:a11c90a6df9cdb57f78dda5d006753259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fb66b44aea8eeab74dd3e2afcae050"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a32fb66b44aea8eeab74dd3e2afcae050">densetosparse</a> (qp_int m, qp_int n, qp_real *pr, <a class="el" href="structsmat.html">smat</a> *A)</td></tr>
<tr class="memdesc:a32fb66b44aea8eeab74dd3e2afcae050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts dense matrix in column major format to CCS format.  <a href="Auxilary_8c.html#a32fb66b44aea8eeab74dd3e2afcae050">More...</a><br /></td></tr>
<tr class="separator:a32fb66b44aea8eeab74dd3e2afcae050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86015dbe531fd91600fc60813de91e75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Auxilary_8c.html#a86015dbe531fd91600fc60813de91e75">densetosparse_ROWMAJOR</a> (qp_int m, qp_int n, qp_real *pr, <a class="el" href="structsmat.html">smat</a> *A)</td></tr>
<tr class="memdesc:a86015dbe531fd91600fc60813de91e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts dense matrix in row major format to CCS format.  <a href="Auxilary_8c.html#a86015dbe531fd91600fc60813de91e75">More...</a><br /></td></tr>
<tr class="separator:a86015dbe531fd91600fc60813de91e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9f4ac1455ae148134c3b2b8340d77614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4ac1455ae148134c3b2b8340d77614">&#9670;&nbsp;</a></span>checksign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qp_int checksign </td>
          <td>(</td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>delta_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if x + alpha*delta_x &lt; 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Flag</td><td>0 : Failure 1 : Success </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>primal variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_x</td><td>search direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>scalar value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0f5b2eb819f1ebde89875602ab32bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f5b2eb819f1ebde89875602ab32bde">&#9670;&nbsp;</a></span>computeresiduals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void computeresiduals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQP.html">QP</a> *&#160;</td>
          <td class="paramname"><em>myQP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the residuals rx, ry and rz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">myQP</td><td><a class="el" href="structQP.html">QP</a> Structure</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">rx = Px + G'z +c
ry = Ax - b
rz = -s - Gx + h
mu = s'z/m
</pre> 
</div>
</div>
<a id="a32fb66b44aea8eeab74dd3e2afcae050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fb66b44aea8eeab74dd3e2afcae050">&#9670;&nbsp;</a></span>densetosparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void densetosparse </td>
          <td>(</td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>pr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts dense matrix in column major format to CCS format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>Sparse Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of rows of A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of columns of A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pr</td><td>pointer to matrix in column major format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86015dbe531fd91600fc60813de91e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86015dbe531fd91600fc60813de91e75">&#9670;&nbsp;</a></span>densetosparse_ROWMAJOR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void densetosparse_ROWMAJOR </td>
          <td>(</td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>pr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts dense matrix in row major format to CCS format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>Sparse Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of rows of A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of columns of A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pr</td><td>pointer to matrix in row major format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a675fa6b6ba93e243d39a837264ade3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a675fa6b6ba93e243d39a837264ade3">&#9670;&nbsp;</a></span>findminmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void findminmax </td>
          <td>(</td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the minimum and maximum of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">min</td><td>Minimum of the vector z </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum of the vector z </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Vector z </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnz</td><td>Length of the vector z </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3399dfc8e5f315c356bea732b7f3eac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3399dfc8e5f315c356bea732b7f3eac2">&#9670;&nbsp;</a></span>findsteplength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void findsteplength </td>
          <td>(</td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>delta_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>delta_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>alpha_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>alpha_d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the step length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">alpha_p</td><td>Primal step length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">alpha_d</td><td>Dual step length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Primal slack variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_s</td><td>Search Direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Dual slack variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_z</td><td>Search Direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td># of inequality constraints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fe4380baed9e0747c89c746a57d7f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe4380baed9e0747c89c746a57d7f1c">&#9670;&nbsp;</a></span>form_ds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void form_ds </td>
          <td>(</td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>delta_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>delta_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the ds vector based on the selector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ds</td><td>vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>Scaling Point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_s</td><td>Search Direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_z</td><td>Search Direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sigma</td><td>centering parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mu</td><td>complementary condition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td># of inequality constraints </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">selector</td><td>selector</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">selector = 1 =&gt; ds = -lambda*lambda; \n
selector = 2 =&gt; ds = -lambda*lambda - (delta_s*delta_z) + (sigma*mu); \n
selector = 3 =&gt; ds = -lambda*lambda + (sigma*mu); \n
</pre> 
</div>
</div>
<a id="adb373533158b8ae2815472c675bbb368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb373533158b8ae2815472c675bbb368">&#9670;&nbsp;</a></span>formkktmatrix_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void formkktmatrix_full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>Gt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>At</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>kkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assembles the KKT matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">kkt</td><td>KKT Matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>Cost Function Matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Equality Constraint Matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A'</td><td>Transpose of A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">G</td><td>Inequality Constraint Matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">G'</td><td>Transpose of G</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">KKT = [P    A'   G']
      [A    0    0]
      [G    0   -I]
</pre> 
</div>
</div>
<a id="ab763700450e282af9ddf438e1545ecda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab763700450e282af9ddf438e1545ecda">&#9670;&nbsp;</a></span>formkktmatrix_U()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void formkktmatrix_U </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>Gt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>kkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forms the Upper triangular part of the kkt matrix</p>
<p>Status: Inactive </p>

</div>
</div>
<a id="adf32272524a1aa13205e37a642425eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf32272524a1aa13205e37a642425eaa">&#9670;&nbsp;</a></span>formlambda()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void formlambda </td>
          <td>(</td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the scaling point lambda. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda</td><td>Scaling Point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Primal slack variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Dual variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>length of the vector</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">lambda = sqrt(s/z)
</pre> 
</div>
</div>
<a id="a34041f76038b85bde98585927b2e4d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34041f76038b85bde98585927b2e4d20">&#9670;&nbsp;</a></span>formrho()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qp_real formrho </td>
          <td>(</td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>delta_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>delta_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real&#160;</td>
          <td class="paramname"><em>alpha_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real&#160;</td>
          <td class="paramname"><em>alpha_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the scalar rho as. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rho</td><td>scalar value rho </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Primal slack variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_s</td><td>delta_s </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Dual Variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_z</td><td>delta_z </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha_p</td><td>Primal Step length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha_d</td><td>Dual Step length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>length of vectors s,z,delta_s and delta_z (# of ineq. constraints)</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">Computes the scalar rho as
rho = (s+alpha_p*delta_s)*(z+alpha_d*delta_z)/s'z;
</pre> 
</div>
</div>
<a id="a2bbda11dfedf5a4f7ce3a67369a346c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbda11dfedf5a4f7ce3a67369a346c5">&#9670;&nbsp;</a></span>innerproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qp_real innerproduct </td>
          <td>(</td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the inner product of two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Inner Product of the vectors x and y i.e, &lt;x,y&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>vector x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>vector y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>length of vectors x and y </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab220a7f17aea42da2f47e2b41d429f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab220a7f17aea42da2f47e2b41d429f54">&#9670;&nbsp;</a></span>kkt_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qp_int kkt_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQP.html">QP</a> *&#160;</td>
          <td class="paramname"><em>myQP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the initial condition for the <a class="el" href="structQP.html">QP</a> problem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">myQP</td><td><a class="el" href="structQP.html">QP</a> Matrix Structure</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">Solves a closely related QP of the form
min. 0.5*x'Px + c'x + s's
s.t     Ax = b
        Gx + s = h
</pre> 
</div>
</div>
<a id="ae747aba2e350a0b16f76d84abcfc8b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae747aba2e350a0b16f76d84abcfc8b47">&#9670;&nbsp;</a></span>kktsolve_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qp_int kktsolve_1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQP.html">QP</a> *&#160;</td>
          <td class="paramname"><em>myQP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the KKT linear systems and updates delta_z and delta_s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Flag</td><td>Flag indicating status of the function; 0 : Failure 1 : Successful </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myQP</td><td><a class="el" href="structQP.html">QP</a> Structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16e87511977785511d2f27c3a1e292af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e87511977785511d2f27c3a1e292af">&#9670;&nbsp;</a></span>kktsolve_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kktsolve_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQP.html">QP</a> *&#160;</td>
          <td class="paramname"><em>myQP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the kktlinear system from results of kktsolve_1 and updates delta_x, delta_y, delta_z and delta_s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">myQP</td><td><a class="el" href="structQP.html">QP</a> Structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79074eedf41b8fa6171741629624464e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79074eedf41b8fa6171741629624464e">&#9670;&nbsp;</a></span>ldlinitialsolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qp_int ldlinitialsolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkkt.html">kkt</a> *&#160;</td>
          <td class="paramname"><em>mykkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the kkt linear system to find initial conditions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mykkt</td><td>KKT Structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>delta varible</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">Invoked by kkt_initialize
Creates and updates the LDL workspace variables
Performs ldl_symbolic and stores the results
Also Performs LDL_numeric ; LDL_perm; LDL_lsolve; LDL_dsolve; LDL_ltsolve; LDL_permt in the same order
</pre> 
</div>
</div>
<a id="a4a16d6b5e6c10eff3b002d3e39b1b531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a16d6b5e6c10eff3b002d3e39b1b531">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qp_real norm </td>
          <td>(</td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the Eucledian two norm of vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Norm of the vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Length of the vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11c90a6df9cdb57f78dda5d006753259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c90a6df9cdb57f78dda5d006753259">&#9670;&nbsp;</a></span>obj_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qp_real obj_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the objective function value f = x'Px + c'x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fval</td><td>Objective Value of <a class="el" href="structQP.html">QP</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>cost Function : quadratic part </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>cost function : linear term </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>primal solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">temp</td><td>temporary workspace variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e1c4de7bb55b169a23336387978f9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1c4de7bb55b169a23336387978f9ce">&#9670;&nbsp;</a></span>SparseMatrixMultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparseMatrixMultiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs Sparse Matrix Vector Multiplication as. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>Outut vector y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Sparse Matrix structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Number of rows of the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Selection index</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">Computes y = y - Ax
start = 0 ; do nothing
start !=0 ; intialize y=0
</pre> 
</div>
</div>
<a id="acc9a808a1d46a1de51805cc5c6d9b94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9a808a1d46a1de51805cc5c6d9b94e">&#9670;&nbsp;</a></span>SparseMatrixSetup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparseMatrixSetup </td>
          <td>(</td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int *&#160;</td>
          <td class="paramname"><em>jc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int *&#160;</td>
          <td class="paramname"><em>ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>pr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>sparse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the Sparse Matrix in Column Compressed Storage Format based on inputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sparse</td><td>Sparse Matrix structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of Columns of the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnz</td><td>Number of Non zeros of the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jc</td><td>Vector to store column count ; Dim [n+1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ir</td><td>Vector to store row indices in column major format ; Dim[nnz] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pr</td><td>Vector to store matrix values in column major format ; Dim[nnz] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26737ca9366dd8793a56246bc7d14ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26737ca9366dd8793a56246bc7d14ea8">&#9670;&nbsp;</a></span>SparseMatrixTransMultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparseMatrixTransMultiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs Sparse Matrix Transpose Vector Multiplication as. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>Outut vector y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Sparse Matrix structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Number of rows of the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Selection index</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">Computes y = y - A'x
start = 0 ; do nothing
start !=0 ; intialize y=0
</pre> 
</div>
</div>
<a id="ae64488b6b77275e10a928aa7158f061b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64488b6b77275e10a928aa7158f061b">&#9670;&nbsp;</a></span>SparseMatrixTranspose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparseMatrixTranspose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>At</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sparse matrix transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>Sparse Matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">At</td><td>Transpose of the Sparse Matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a129b9809017a0271070faee2a6fabce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129b9809017a0271070faee2a6fabce1">&#9670;&nbsp;</a></span>test_reach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_reach </td>
          <td>(</td>
          <td class="paramtype">qp_int *&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int *&#160;</td>
          <td class="paramname"><em>Pinv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int *&#160;</td>
          <td class="paramname"><em>UPattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the nodes to be updated at each iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">UPattern</td><td>Reach of the nodes of the lower diagonal part of KKT Matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td># of decision variables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td># of inequality constraints </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td># of equality constraints </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Parent</td><td>Parent tree of the KKT Matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pinv</td><td>Inverse of Permutation vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1e90f986dbd2bb32b0ee28fc722d999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e90f986dbd2bb32b0ee28fc722d999">&#9670;&nbsp;</a></span>Transpose_Row_Count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Transpose_Row_Count </td>
          <td>(</td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int *&#160;</td>
          <td class="paramname"><em>Li</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int *&#160;</td>
          <td class="paramname"><em>Lp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int *&#160;</td>
          <td class="paramname"><em>Lti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int *&#160;</td>
          <td class="paramname"><em>Ltp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the ir and jc of transpose of a Matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Lti</td><td>ir vector of the transpose of sparse choelsky matrix L (Lt-&gt;ir) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Ltp</td><td>jc vector of the transpose of sparse choelsky matrix L (Lt-&gt;jc) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows the matrix L </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of the matrix L </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Li</td><td>ir vector of the sparse choelsky matrix L (L-&gt;ir) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Lp</td><td>jc vector of the sparse choelsky matrix L (L-&gt;jc) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd460d31cc93071880545e49d47c87ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd460d31cc93071880545e49d47c87ce">&#9670;&nbsp;</a></span>updatekktmatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updatekktmatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsmat.html">smat</a> *&#160;</td>
          <td class="paramname"><em>kkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>delta_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>delta_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real&#160;</td>
          <td class="paramname"><em>alpha_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real&#160;</td>
          <td class="paramname"><em>alpha_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>indicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lower diagonal part of the kkt Matrix,. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">kkt</td><td>KKT Matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Primal Slack Variables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Dual Variables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_s</td><td>Primal slack direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_z</td><td>Dual slack direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha_p</td><td>Primal step Length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha_d</td><td>Dual step length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td># of ineqaulity constraints </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td># of decision variables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td># of equality constraints </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indicator</td><td>selection vector</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">indicator = 1 : Pure Affine Direction
indicator = 2 : Pure Centering Direction
indicator = 3 : Pure Newton Direction
</pre> 
</div>
</div>
<a id="adaf2773ce4d9305e5125c82bc64a8b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf2773ce4d9305e5125c82bc64a8b19">&#9670;&nbsp;</a></span>updatekktmatrix_b()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updatekktmatrix_b </td>
          <td>(</td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>ry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>rz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the right hand side of the KKT linear system of equations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>KKT Matrix right-hand side vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rx</td><td>Residual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ry</td><td>Residual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rz</td><td>Residual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>vector ds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Residual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td># of inequality constraints </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td># of decision variables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td># of equality constraints</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">b = [rx]
    [ry]
    [rz] - [ds]/[z]
</pre> 
</div>
</div>
<a id="a4e8d89cdd4ec5f5c63e838a3760283ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8d89cdd4ec5f5c63e838a3760283ba">&#9670;&nbsp;</a></span>updatevariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updatevariables </td>
          <td>(</td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real *&#160;</td>
          <td class="paramname"><em>delta_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_real&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qp_int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs scalar vector addition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>scalar value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_x</td><td>search direction</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">x = x + alpha*delta_x
</pre> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="Auxilary_8c.html">Auxilary.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
